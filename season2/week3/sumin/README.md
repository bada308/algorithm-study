문제를 이해하다보면 문제유형 분류는 힙으로 되어있지만 우선순위 큐를 사용해야했다.

그래서 우선순위 큐와 힙이 관계가 있나? 라는 생각이 들었고 이번 기회에 알아보고자 한다.
## 우선순위 큐란?
들어간 순서에 상관없이 우선순위가 높은 데이터가 먼저 나오는 것

## 힙이란?
힙 자료구조는 **완전 이진 트리**를 기반으로 하는 자료구조이다.
힙은 최댓값 또는 최솟값을 쉽게 뽑기 위해 사용한다.

<img width="259" alt="image" src="https://user-images.githubusercontent.com/88534959/226130169-902e3e45-9443-45fe-a4f5-82a74dbb1e59.png">

* 부모 노드의 인덱스 = 자식 노드의 인덱스 / 2
* 왼쪽 자식 노드의 인덱스 = 부모 노드의 인덱스 * 2
* 오른쪽 자식 노드의 인덱스 = 부모 노드의 인덱스 * 2 + 1

> 트리란?
부모 자녀처럼 계층적인 형태를 가지는 구조
이러한 계층 구조를 나타내기 위해 트리를 사용한다.

> 이진 트리?
자녀가 최대 2개인 트리

> 완전 이진 트리란?
이진 트리에 노드를 삽입할 때 왼쪽부터 차례대로 삽입하는 트리이다.

힙은 최대힙과 최소힙으로 나눠진다.
* 최대힙 : 부모노드의 값이 자식노드들의 값보다 항상 크다.
* 최소힙 : 부모노드의 값이 자식노드의 값보다 항상 작다.

또함 힙은 중복값을 허용한다.

## 힙의 동작
### 데이터 삽입
힙은 완전 이진 트리이기 때문에, 
1. 삽입할 노드는 기본적으로 왼쪽 최하단부 노드부터 채워진다.
2. 이후, 채워진 노드 위치에서, 부모 노드의 값보다 클 경우에는 부모 노드와 위치를 바꾸며 이를 반복한다.

<img width="714" alt="image" src="https://user-images.githubusercontent.com/88534959/226130484-996e8ae7-197b-46b4-a312-bd7a74c900a1.png">
<img width="344" alt="image" src="https://user-images.githubusercontent.com/88534959/226130538-24934654-4cbc-4237-bb06-67bd9b56889e.png">

삽입 데이터가 해당 데이터의 부모 데이터보다 클 경우 데이터 삽입은 다음과 같이 이뤄진다.
1. 20을 왼쪽 최하단부에 삽입한다.
2. 20의 부모노드인 8과 20를 비교했더니 자식 노드의 값이 더 작다 따라서 위치를 swap한다.
3. 20과 15를 비교했더니 자식노드의 값이 더 크다. 그래서 위치를 바꾼다.
4. 루트 노드이므로 비교대상이 없다. 종료

#### 데이터 삽입의 시간복잡도
최악의 경우는 추가된 노드가 부모 노드와 비교를 하다가 root 노드와 비교하는 상황이다.

이때는 트리의 높이만큼 비교를 한다고 할 수 있다.

트리의 높이는 마지막 레벨가지 꽉찬 포화 이진 트리에서 log(n+1)로 나타낼 수 있고 따라서 자료를 추가하는 시간복잡도는 O(logN)이다.


### 데이터 삭제
**힙 자료구조의 목표는 최대값이나 최소값을 알아내는 것**이다.
따라서 데이터가 삭제된다면 가장 큰 값인 부모 노드의 값이 삭제된다.
<img width="709" alt="image" src="https://user-images.githubusercontent.com/88534959/226138051-c1b6b55d-b592-410f-a792-b84cb3b0cd5f.png">

1.최댓값을 갖는 부모 노드를 삭제한다.
<img width="710" alt="image" src="https://user-images.githubusercontent.com/88534959/226138063-325c9432-076a-4760-b232-309f241948d9.png">
2. 부모 노드가 비었으므로, 가장 최하단부 노드를 루트로 옮긴다.
3. 부모 노드인 8보다 값이 큰 자식 노드가 있는지 확인한다.(10과 15를 비교했을 때 15가 더크므로 8과 15를 비교한다.)
4. 부모 노드의 해당 자식노드의 값을 바꾼다.(swap)

### 데이터 삭제의 시간복잡도
최악의 경우 트리의 제일 깊은곳까지 내려가므로 

트리의 높이가 연산 횟수가 되고 따라서 O(logN)의 시간복잡도를 가진다.


### 우선순위 큐는 왜 힙을 기반으로 구현할까?
#### 배열로 구현
우선 순위가 높은 순서대로 배열의 가장 앞부분에 넣는다면,

1. 반환: 우선순위가 가장 높은 값을 반환하고자 할 때는 맨 앞의 인덱스를 이용 -> 어렵지 않다.
2. 삽입 : 우선순위가 중간인 값을 삽입하고자 하면, 뒤의 데이터까지 인덱스를 한칸식 뒤로 밀어야 한다.
* 최악의 경우 삽입해야 하는 위치를 찾기 위해 모든 인덱스를 탐색해야 한다. 즉, 이때의 시간복잡도는 O(n)이다.

베열로 구현 시 삭제는 O(1), 삽입은 O(n)

#### 연결리스트로 구현
1. 반환 : 우선순위가 가장 높은 값을 반환하고자 할 때는 맨 앞의 노드의 값을 반환 -> 어렵지 않다.
2. 삽입 : 최악의 경우 삽입하고자 하는 값의 위치를 찾고자 맨 끝까지 이동해야 한다. 즉, 이때의 시간복잡도는 O(n)이다.

베열로 구현 시 삭제는 O(1), 삽입은 O(n)

### 힙으로 구현
1. 삽입/삭제 : 삽입 시 마지막 위치에 요소를 추가시킨 후 부모 노드와의 비교를 통해 swap과정으로 알맞은 위치로 찾아간다. -> 즉, 이때의 시간복잡도는 O(logn)이다.
2. 반환 : 큐에서는 front의 시간복잡도가 O(1)이다(Linked List로 구현). 하지만, 우선순위 큐에서는 가장 우선순위가 높은 값을 가져온 후 완전 이진 트리로 만드는 과정인 swap과정이 필요하다. -> O(logn)


### 트리의 장점
* Array
  * 검색 : 배열처럼 인덱스를 가지고 있어서 데이터 검색에 적합하고 속도가 빠름 -> O(1)
  * 삽입/삭제 : 해당 데이터를 삽입함으로써 해당 데이터 뒤에 위치한 데이터의 index를 변경해야 함 -> O(n)
* Dynamic Array
  * 검색 : 배열처럼 인덱스를 가지고 있어서 데이터 검색에 적합하고 속도가 빠름 -> O(1)
  * 삽입/삭제 : 해당 데이터를 제외한 모든 데이터를 임시 배열을 생성해 복사하여 속도가 느림 -> O(n)
* Linked List
  * 검색 : 해당 데이터를 찾기 위해 리스트를 순회해야 한다. -> O(n)
  * 삽입/삭제 : 임의의 원소를 찾기 위해 순회 후 작업을 수행하므로 순회로 인해 O(n)

