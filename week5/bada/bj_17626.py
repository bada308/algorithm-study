'''
문제 : Four Squares
난이도 : 실버 3

모든 자연수는 넷 혹은 그 이하의 제곱수의 합으로 표현할 수 있음
자연수 n을 입력받으면 합이 n과 같게 되는 제곱수들의 최소 개수 출력

네 모르겠어서 알고리즘 분류 봤습니다..
- 다이나믹 프로그래밍
- 브루스포스 알고리즘

#1
dp로 제곱수를 저장하는 것 같은데..
어떻게 조합해야 n이 되는 걸 어떻게 알지?
여기서 완전탐색을 쓴다고???
무작정 다 비교하는건가????

#2
검색했다
규칙은 n - (n보다 작거나 같은 제곱수) 를 인덱스로 갖는 값에 1을 더해주면 된다. 
라고 나오는데
왜 규칙이 이건지 모르겠다.

#3
와 드디어 이해했다~~~~~
- dp 각 인덱스에는 합이 인덱스값과 같게 되는 제곱수들의 최소 개수를 저장한다.
- dp가 N+1개의 길이인 것은 자연수가 1부터 시작해서 해당 숫자의 경우의 수에 맞게끔 접근하기 위해서다.
- dp = [0, 1] // 자연수 1은 1의 제곱으로만 나타낼 수 있다.
- N의 제곱근 만큼의 범위까지 탐색하면서 각 N의 제곱근보다 작은 자연수들의 최소 거듭제곱 경우의 수를 탐색한다.

ex) 11
j**2 + i - (j**2) 임
i) 1 + 10
ii) 4 + 7
iii) 9 + 2

총 3가지 경우의 수를 비교해야함
이 중 최솟값에 +1 (j)

-> Python3는 시간초과 PyPy3로 해야한다
'''
import sys

n = int(sys.stdin.readline())

dp = [0] * (n+1)
dp[1] = 1

for i in range(2, n+1):
    minimum = sys.maxsize
    for j in range(1, int(i ** 0.5)+1):
        minimum = min(minimum, dp[i - (j ** 2)])
    dp[i] = minimum + 1
print(dp[n])
