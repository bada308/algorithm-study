'''
/*문제 정보 */
21758번 - 꿀 따기
난이도 - 골드 5
/*풀이 방법 */
아무리 생각해도 신박한 풀이가 떠오르지 않아 코드리뷰 했습니다!
https://sodehdt-ldkt.tistory.com/53
제가 이해한 것을 설명하면 이 문제는 3가지 케이스입니다.

1. 벌통이 맨 왼쪽에 있는 경우
    - 이 경우 최댓값을 구하기 위해선 벌 한마리는 맨 오른쪽에 있고 나머지 한마리만 찾아주면됩니다.
2. 벌통이 맨 오른쪽에 있는 경우
    - 1번 경우와 방향만 다르고 같은 경우입니다.
3. 벌통이 1,2번을 제외한 경우
    - 이 경우는 벌이 왼쪽, 오른쪽 각 끝에 위치하는 경우라고 생각하고 벌통 위치만 골라주면됩니다.
    - 이 경우는 좌우 끝 값을 빼주고, 꿀통 위치의 값만 한번 더 더해주는 경우라 쉽습니다.

그리고 이 문제를 쉽게 풀기 위해 누적합 리스트를 만들어주면 편합니다.
입력 받은 리스트와 별개로 처음부터 i번째까지 원소의 누적합을 저장하는 리스트를 만들어주어
케이스 별로 계산하기 쉽게 할 수 있습니다.
'''
import sys
input = sys.stdin.readline

n = int(input())
data = list(map(int, input().split()))

# 최대값 저장 변수
ans = 0

# i번째 원소까지의 누적합
sum = []
sum.append(data[0])

for i in range(1, n):
    sum.append(sum[i - 1] + data[i])

# case1 - left
for i in range(1, n - 1):
    ans = max(ans, sum[n - 2] + sum[i - 1] - data[i])
    # 왼쪽 끝에 벌통
    # 오른쪽 끝에 벌1, i번쨰 위치에 벌2

# case2 - right
for i in range(1, n - 1):
    ans = max(ans, sum[n - 1] - data[0] - data[i] + sum[n - 1] - sum[i])
    # 오른쪽 끝에 벌통
    # 왼쪽 끝에 벌1, i번째 위치에 벌2

# case3 - middle
for i in range(1, n - 1):
    ans = max(ans, sum[n - 2] - data[0] + data[i])
    # 왼쪽 끝에 벌1, 오른쪽 끝에 벌2
    # i번째 위치에 벌통

print(ans)

'''
/*오답 노트*/
/*느낀 점*/
쉬워 보인다 생각해 가볍게 생각했다가 벌통 위치에 따라 벌 이동방향이 달라지는 걸 생각하고
무작정 너무 어렵게 생각해서 더 어려워했는데 막상 리뷰하니 생각보다 쉬운 것 같았다.
근데 도저히 내 머리로는 생각할 수 없는 아이디어다...
'''